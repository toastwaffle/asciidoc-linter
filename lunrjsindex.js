var documents = [

{
    "id": 0,
    "uri": "test-results/test-report.html",
    "menu": "null",
    "title": "null",
    "text": " test_report_20241221_224323.html body { font-family: Helvetica, Arial, sans-serif; font-size: 12px; /* do not increase min-width as some may use split screens */ min-width: 800px; color: #999; } h1 { font-size: 24px; color: black; } h2 { font-size: 16px; color: black; } p { color: black; } a { color: #999; } table { border-collapse: collapse; } /****************************** * SUMMARY INFORMATION ******************************/ #environment td { padding: 5px; border: 1px solid #e6e6e6; vertical-align: top; } #environment tr:nth-child(odd) { background-color: #f6f6f6; } #environment ul { margin: 0; padding: 0 20px; } /****************************** * TEST RESULT COLORS ******************************/ span.passed, .passed .col-result { color: green; } span.skipped, span.xfailed, span.rerun, .skipped .col-result, .xfailed .col-result, .rerun .col-result { color: orange; } span.error, span.failed, span.xpassed, .error .col-result, .failed .col-result, .xpassed .col-result { color: red; } .col-links__extra { margin-right: 3px; } /****************************** * RESULTS TABLE * * 1. Table Layout * 2. Extra * 3. Sorting items * ******************************/ /*------------------ * 1. Table Layout *------------------*/ #results-table { border: 1px solid #e6e6e6; color: #999; font-size: 12px; width: 100%; } #results-table th, #results-table td { padding: 5px; border: 1px solid #e6e6e6; text-align: left; } #results-table th { font-weight: bold; } /*------------------ * 2. Extra *------------------*/ .logwrapper { max-height: 230px; overflow-y: scroll; background-color: #e6e6e6; } .logwrapper.expanded { max-height: none; } .logwrapper.expanded .logexpander:after { content: \"collapse [-]\"; } .logwrapper .logexpander { z-index: 1; position: sticky; top: 10px; width: max-content; border: 1px solid; border-radius: 3px; padding: 5px 7px; margin: 10px 0 10px calc(100% - 80px); cursor: pointer; background-color: #e6e6e6; } .logwrapper .logexpander:after { content: \"expand [+]\"; } .logwrapper .logexpander:hover { color: #000; border-color: #000; } .logwrapper .log { min-height: 40px; position: relative; top: -50px; height: calc(100% + 50px); border: 1px solid #e6e6e6; color: black; display: block; font-family: \"Courier New\", Courier, monospace; padding: 5px; padding-right: 80px; white-space: pre-wrap; } div.media { border: 1px solid #e6e6e6; float: right; height: 240px; margin: 0 5px; overflow: hidden; width: 320px; } .media-container { display: grid; grid-template-columns: 25px auto 25px; align-items: center; flex: 1 1; overflow: hidden; height: 200px; } .media-container--fullscreen { grid-template-columns: 0px auto 0px; } .media-container__nav--right, .media-container__nav--left { text-align: center; cursor: pointer; } .media-container__viewport { cursor: pointer; text-align: center; height: inherit; } .media-container__viewport img, .media-container__viewport video { object-fit: cover; width: 100%; max-height: 100%; } .media__name, .media__counter { display: flex; flex-direction: row; justify-content: space-around; flex: 0 0 25px; align-items: center; } .collapsible td:not(.col-links) { cursor: pointer; } .collapsible td:not(.col-links):hover::after { color: #bbb; font-style: italic; cursor: pointer; } .col-result { width: 130px; } .col-result:hover::after { content: \" (hide details)\"; } .col-result.collapsed:hover::after { content: \" (show details)\"; } #environment-header h2:hover::after { content: \" (hide details)\"; color: #bbb; font-style: italic; cursor: pointer; font-size: 12px; } #environment-header.collapsed h2:hover::after { content: \" (show details)\"; color: #bbb; font-style: italic; cursor: pointer; font-size: 12px; } /*------------------ * 3. Sorting items *------------------*/ .sortable { cursor: pointer; } .sortable.desc:after { content: \" \"; position: relative; left: 5px; bottom: -12.5px; border: 10px solid #4caf50; border-bottom: 0; border-left-color: transparent; border-right-color: transparent; } .sortable.asc:after { content: \" \"; position: relative; left: 5px; bottom: 12.5px; border: 10px solid #4caf50; border-top: 0; border-left-color: transparent; border-right-color: transparent; } .hidden, .summary__reload__button.hidden { display: none; } .summary__data { flex: 0 0 550px; } .summary__reload { flex: 1 1; display: flex; justify-content: center; } .summary__reload__button { flex: 0 0 300px; display: flex; color: white; font-weight: bold; background-color: #4caf50; text-align: center; justify-content: center; align-items: center; border-radius: 3px; cursor: pointer; } .summary__reload__button:hover { background-color: #46a049; } .summary__spacer { flex: 0 0 550px; } .controls { display: flex; justify-content: space-between; } .filters, .collapse { display: flex; align-items: center; } .filters button, .collapse button { color: #999; border: none; background: none; cursor: pointer; text-decoration: underline; } .filters button:hover, .collapse button:hover { color: #ccc; } .filter__label { margin-right: 10px; } test_report_20241221_224323.html Report generated on 21-Dec-2024 at 22:43:25 by pytest-html v4.1.1 Environment No results found. Check the filters. > Summary 127 tests took 180 ms. (Un)check the boxes to filter the results. There are still tests running. Reload this page to get the latest results! 0 Failed, 127 Passed, 0 Skipped, 0 Expected failures, 0 Unexpected passes, 0 Errors, 0 Reruns Show all details &nbsp;/&nbsp; Hide all details Result Test Duration Links (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i { const collapsed = collapsedCategories.includes(test.result.toLowerCase()) const id = `test_${index}` if (collapsed) { collapsedIds.push(id) } return { ...test, id, collapsed, } }) const dataBlob = { ...data, tests } this.data = { ...dataBlob } this.renderData = { ...dataBlob } setCollapsedIds(collapsedIds) } get allData() { return { ...this.data } } resetRender() { this.renderData = { ...this.data } } setRender(data) { this.renderData.tests = [...data] } toggleCollapsedItem(id) { this.renderData.tests = this.renderData.tests.map((test) => test.id === id ? { ...test, collapsed: !test.collapsed } : test, ) } set allCollapsed(collapsed) { this.renderData = { ...this.renderData, tests: [...this.renderData.tests.map((test) => ( { ...test, collapsed } ))] } } get testSubset() { return [...this.renderData.tests] } get environment() { return this.renderData.environment } get initialSort() { return this.data.initialSort } } module.exports = { manager: new DataManager(), } },{\"./storage.js\":8}],2:[function(require,module,exports){ const mediaViewer = require('./mediaviewer.js') const templateEnvRow = document.getElementById('template_environment_row') const templateResult = document.getElementById('template_results-table__tbody') function htmlToElements(html) { const temp = document.createElement('template') temp.innerHTML = html return temp.content.childNodes } const find = (selector, elem) => { if (!elem) { elem = document } return elem.querySelector(selector) } const findAll = (selector, elem) => { if (!elem) { elem = document } return [...elem.querySelectorAll(selector)] } const dom = { getStaticRow: (key, value) => { const envRow = templateEnvRow.content.cloneNode(true) const isObj = typeof value === 'object' && value !== null const values = isObj ? Object.keys(value).map((k) => `${k}: ${value[k]}`) : null const valuesElement = htmlToElements( values ? ` ${values.map((val) => ` ${val} `).join('')} ` : ` ${value} `)[0] const td = findAll('td', envRow) td[0].textContent = key td[1].appendChild(valuesElement) return envRow }, getResultTBody: ({ testId, id, log, extras, resultsTableRow, tableHtml, result, collapsed }) => { const resultBody = templateResult.content.cloneNode(true) resultBody.querySelector('tbody').classList.add(result.toLowerCase()) resultBody.querySelector('tbody').id = testId resultBody.querySelector('.collapsible').dataset.id = id resultsTableRow.forEach((html) => { const t = document.createElement('template') t.innerHTML = html resultBody.querySelector('.collapsible').appendChild(t.content) }) if (log) { // Wrap lines starting with \"E\" with span.error to color those lines red const wrappedLog = log.replace(/^E.*$/gm, (match) => ` ${match} `) resultBody.querySelector('.log').innerHTML = wrappedLog } else { resultBody.querySelector('.log').remove() } if (collapsed) { resultBody.querySelector('.collapsible > td')?.classList.add('collapsed') resultBody.querySelector('.extras-row').classList.add('hidden') } else { resultBody.querySelector('.collapsible > td')?.classList.remove('collapsed') } const media = [] extras?.forEach(({ name, format_type, content }) => { if (['image', 'video'].includes(format_type)) { media.push({ path: content, name, format_type }) } if (format_type === 'html') { resultBody.querySelector('.extraHTML').insertAdjacentHTML('beforeend', ` ${content} `) } }) mediaViewer.setup(resultBody, media) // Add custom html from the pytest_html_results_table_html hook tableHtml?.forEach((item) => { resultBody.querySelector('td[class=\"extra\"]').insertAdjacentHTML('beforeend', item) }) return resultBody }, } module.exports = { dom, htmlToElements, find, findAll, } },{\"./mediaviewer.js\":6}],3:[function(require,module,exports){ const { manager } = require('./datamanager.js') const { doSort } = require('./sort.js') const storageModule = require('./storage.js') const getFilteredSubSet = (filter) => manager.allData.tests.filter(({ result }) => filter.includes(result.toLowerCase())) const doInitFilter = () => { const currentFilter = storageModule.getVisible() const filteredSubset = getFilteredSubSet(currentFilter) manager.setRender(filteredSubset) } const doFilter = (type, show) => { if (show) { storageModule.showCategory(type) } else { storageModule.hideCategory(type) } const currentFilter = storageModule.getVisible() const filteredSubset = getFilteredSubSet(currentFilter) manager.setRender(filteredSubset) const sortColumn = storageModule.getSort() doSort(sortColumn, true) } module.exports = { doFilter, doInitFilter, } },{\"./datamanager.js\":1,\"./sort.js\":7,\"./storage.js\":8}],4:[function(require,module,exports){ const { redraw, bindEvents, renderStatic } = require('./main.js') const { doInitFilter } = require('./filter.js') const { doInitSort } = require('./sort.js') const { manager } = require('./datamanager.js') const data = JSON.parse(document.getElementById('data-container').dataset.jsonblob) function init() { manager.setManager(data) doInitFilter() doInitSort() renderStatic() redraw() bindEvents() } init() },{\"./datamanager.js\":1,\"./filter.js\":3,\"./main.js\":5,\"./sort.js\":7}],5:[function(require,module,exports){ const { dom, find, findAll } = require('./dom.js') const { manager } = require('./datamanager.js') const { doSort } = require('./sort.js') const { doFilter } = require('./filter.js') const { getVisible, getCollapsedIds, setCollapsedIds, getSort, getSortDirection, possibleFilters, } = require('./storage.js') const removeChildren = (node) => { while (node.firstChild) { node.removeChild(node.firstChild) } } const renderStatic = () => { const renderEnvironmentTable = () => { const environment = manager.environment const rows = Object.keys(environment).map((key) => dom.getStaticRow(key, environment[key])) const table = document.getElementById('environment') removeChildren(table) rows.forEach((row) => table.appendChild(row)) } renderEnvironmentTable() } const addItemToggleListener = (elem) => { elem.addEventListener('click', ({ target }) => { const id = target.parentElement.dataset.id manager.toggleCollapsedItem(id) const collapsedIds = getCollapsedIds() if (collapsedIds.includes(id)) { const updated = collapsedIds.filter((item) => item !== id) setCollapsedIds(updated) } else { collapsedIds.push(id) setCollapsedIds(collapsedIds) } redraw() }) } const renderContent = (tests) => { const sortAttr = getSort(manager.initialSort) const sortAsc = JSON.parse(getSortDirection()) const rows = tests.map(dom.getResultTBody) const table = document.getElementById('results-table') const tableHeader = document.getElementById('results-table-head') const newTable = document.createElement('table') newTable.id = 'results-table' // remove all sorting classes and set the relevant findAll('.sortable', tableHeader).forEach((elem) => elem.classList.remove('asc', 'desc')) tableHeader.querySelector(`.sortable[data-column-type=\"${sortAttr}\"]`)?.classList.add(sortAsc ? 'desc' : 'asc') newTable.appendChild(tableHeader) if (!rows.length) { const emptyTable = document.getElementById('template_results-table__body--empty').content.cloneNode(true) newTable.appendChild(emptyTable) } else { rows.forEach((row) => { if (!!row) { findAll('.collapsible td:not(.col-links', row).forEach(addItemToggleListener) find('.logexpander', row).addEventListener('click', (evt) => evt.target.parentNode.classList.toggle('expanded'), ) newTable.appendChild(row) } }) } table.replaceWith(newTable) } const renderDerived = () => { const currentFilter = getVisible() possibleFilters.forEach((result) => { const input = document.querySelector(`input[data-test-result=\"${result}\"]`) input.checked = currentFilter.includes(result) }) } const bindEvents = () => { const filterColumn = (evt) => { const { target: element } = evt const { testResult } = element.dataset doFilter(testResult, element.checked) const collapsedIds = getCollapsedIds() const updated = manager.renderData.tests.map((test) => { return { ...test, collapsed: collapsedIds.includes(test.id), } }) manager.setRender(updated) redraw() } const header = document.getElementById('environment-header') header.addEventListener('click', () => { const table = document.getElementById('environment') table.classList.toggle('hidden') header.classList.toggle('collapsed') }) findAll('input[name=\"filter_checkbox\"]').forEach((elem) => { elem.addEventListener('click', filterColumn) }) findAll('.sortable').forEach((elem) => { elem.addEventListener('click', (evt) => { const { target: element } = evt const { columnType } = element.dataset doSort(columnType) redraw() }) }) document.getElementById('show_all_details').addEventListener('click', () => { manager.allCollapsed = false setCollapsedIds([]) redraw() }) document.getElementById('hide_all_details').addEventListener('click', () => { manager.allCollapsed = true const allIds = manager.renderData.tests.map((test) => test.id) setCollapsedIds(allIds) redraw() }) } const redraw = () => { const { testSubset } = manager renderContent(testSubset) renderDerived() } module.exports = { redraw, bindEvents, renderStatic, } },{\"./datamanager.js\":1,\"./dom.js\":2,\"./filter.js\":3,\"./sort.js\":7,\"./storage.js\":8}],6:[function(require,module,exports){ class MediaViewer { constructor(assets) { this.assets = assets this.index = 0 } nextActive() { this.index = this.index === this.assets.length - 1 ? 0 : this.index + 1 return [this.activeFile, this.index] } prevActive() { this.index = this.index === 0 ? this.assets.length - 1 : this.index -1 return [this.activeFile, this.index] } get currentIndex() { return this.index } get activeFile() { return this.assets[this.index] } } const setup = (resultBody, assets) => { if (!assets.length) { resultBody.querySelector('.media').classList.add('hidden') return } const mediaViewer = new MediaViewer(assets) const container = resultBody.querySelector('.media-container') const leftArrow = resultBody.querySelector('.media-container__nav--left') const rightArrow = resultBody.querySelector('.media-container__nav--right') const mediaName = resultBody.querySelector('.media__name') const counter = resultBody.querySelector('.media__counter') const imageEl = resultBody.querySelector('img') const sourceEl = resultBody.querySelector('source') const videoEl = resultBody.querySelector('video') const setImg = (media, index) => { if (media?.format_type === 'image') { imageEl.src = media.path imageEl.classList.remove('hidden') videoEl.classList.add('hidden') } else if (media?.format_type === 'video') { sourceEl.src = media.path videoEl.classList.remove('hidden') imageEl.classList.add('hidden') } mediaName.innerText = media?.name counter.innerText = `${index + 1} / ${assets.length}` } setImg(mediaViewer.activeFile, mediaViewer.currentIndex) const moveLeft = () => { const [media, index] = mediaViewer.prevActive() setImg(media, index) } const doRight = () => { const [media, index] = mediaViewer.nextActive() setImg(media, index) } const openImg = () => { window.open(mediaViewer.activeFile.path, '_blank') } if (assets.length === 1) { container.classList.add('media-container--fullscreen') } else { leftArrow.addEventListener('click', moveLeft) rightArrow.addEventListener('click', doRight) } imageEl.addEventListener('click', openImg) } module.exports = { setup, } },{}],7:[function(require,module,exports){ const { manager } = require('./datamanager.js') const storageModule = require('./storage.js') const genericSort = (list, key, ascending, customOrder) => { let sorted if (customOrder) { sorted = list.sort((a, b) => { const aValue = a.result.toLowerCase() const bValue = b.result.toLowerCase() const aIndex = customOrder.findIndex((item) => item.toLowerCase() === aValue) const bIndex = customOrder.findIndex((item) => item.toLowerCase() === bValue) // Compare the indices to determine the sort order return aIndex - bIndex }) } else { sorted = list.sort((a, b) => a[key] === b[key] ? 0 : a[key] > b[key] ? 1 : -1) } if (ascending) { sorted.reverse() } return sorted } const durationSort = (list, ascending) => { const parseDuration = (duration) => { if (duration.includes(':')) { // If it's in the format \"HH:mm:ss\" const [hours, minutes, seconds] = duration.split(':').map(Number) return (hours * 3600 + minutes * 60 + seconds) * 1000 } else { // If it's in the format \"nnn ms\" return parseInt(duration) } } const sorted = list.sort((a, b) => parseDuration(a['duration']) - parseDuration(b['duration'])) if (ascending) { sorted.reverse() } return sorted } const doInitSort = () => { const type = storageModule.getSort(manager.initialSort) const ascending = storageModule.getSortDirection() const list = manager.testSubset const initialOrder = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed', 'Skipped', 'Passed'] storageModule.setSort(type) storageModule.setSortDirection(ascending) if (type?.toLowerCase() === 'original') { manager.setRender(list) } else { let sortedList switch (type) { case 'duration': sortedList = durationSort(list, ascending) break case 'result': sortedList = genericSort(list, type, ascending, initialOrder) break default: sortedList = genericSort(list, type, ascending) break } manager.setRender(sortedList) } } const doSort = (type, skipDirection) => { const newSortType = storageModule.getSort(manager.initialSort) !== type const currentAsc = storageModule.getSortDirection() let ascending if (skipDirection) { ascending = currentAsc } else { ascending = newSortType ? false : !currentAsc } storageModule.setSort(type) storageModule.setSortDirection(ascending) const list = manager.testSubset const sortedList = type === 'duration' ? durationSort(list, ascending) : genericSort(list, type, ascending) manager.setRender(sortedList) } module.exports = { doInitSort, doSort, } },{\"./datamanager.js\":1,\"./storage.js\":8}],8:[function(require,module,exports){ const possibleFilters = [ 'passed', 'skipped', 'failed', 'error', 'xfailed', 'xpassed', 'rerun', ] const getVisible = () => { const url = new URL(window.location.href) const settings = new URLSearchParams(url.search).get('visible') const lower = (item) => { const lowerItem = item.toLowerCase() if (possibleFilters.includes(lowerItem)) { return lowerItem } return null } return settings === null ? possibleFilters : [...new Set(settings?.split(',').map(lower).filter((item) => item))] } const hideCategory = (categoryToHide) => { const url = new URL(window.location.href) const visibleParams = new URLSearchParams(url.search).get('visible') const currentVisible = visibleParams ? visibleParams.split(',') : [...possibleFilters] const settings = [...new Set(currentVisible)].filter((f) => f !== categoryToHide).join(',') url.searchParams.set('visible', settings) window.history.pushState({}, null, unescape(url.href)) } const showCategory = (categoryToShow) => { if (typeof window === 'undefined') { return } const url = new URL(window.location.href) const currentVisible = new URLSearchParams(url.search).get('visible')?.split(',').filter(Boolean) || [...possibleFilters] const settings = [...new Set([categoryToShow, ...currentVisible])] const noFilter = possibleFilters.length === settings.length || !settings.length noFilter ? url.searchParams.delete('visible') : url.searchParams.set('visible', settings.join(',')) window.history.pushState({}, null, unescape(url.href)) } const getSort = (initialSort) => { const url = new URL(window.location.href) let sort = new URLSearchParams(url.search).get('sort') if (!sort) { sort = initialSort || 'result' } return sort } const setSort = (type) => { const url = new URL(window.location.href) url.searchParams.set('sort', type) window.history.pushState({}, null, unescape(url.href)) } const getCollapsedCategory = (renderCollapsed) => { let categories if (typeof window !== 'undefined') { const url = new URL(window.location.href) const collapsedItems = new URLSearchParams(url.search).get('collapsed') switch (true) { case !renderCollapsed && collapsedItems === null: categories = ['passed'] break case collapsedItems?.length === 0 || /^[\"']{2}$/.test(collapsedItems): categories = [] break case /^all$/.test(collapsedItems) || collapsedItems === null && /^all$/.test(renderCollapsed): categories = [...possibleFilters] break default: categories = collapsedItems?.split(',').map((item) => item.toLowerCase()) || renderCollapsed break } } else { categories = [] } return categories } const getSortDirection = () => JSON.parse(sessionStorage.getItem('sortAsc')) || false const setSortDirection = (ascending) => sessionStorage.setItem('sortAsc', ascending) const getCollapsedIds = () => JSON.parse(sessionStorage.getItem('collapsedIds')) || [] const setCollapsedIds = (list) => sessionStorage.setItem('collapsedIds', JSON.stringify(list)) module.exports = { getVisible, hideCategory, showCategory, getCollapsedIds, setCollapsedIds, getSort, setSort, getSortDirection, setSortDirection, getCollapsedCategory, possibleFilters, } },{}]},{},[4]); "
},

{
    "id": 1,
    "uri": "arc42/index.html",
    "menu": "arc42",
    "title": "AsciiDoc Linter Architecture Documentation",
    "text": " Table of Contents AsciiDoc Linter Architecture Documentation Introduction and Goals Requirements Overview Quality Goals Stakeholders Architecture Constraints Technical Constraints Organizational Constraints Conventions System Scope and Context Business Context Technical Context Solution Strategy Quality Goals and Architectural Approaches Technology Decisions Implementation Patterns Building Block View Level 1 - System Overview Level 2 - Core Components Level 3 - Rule Implementation Runtime View Document Processing Sequence Rule Loading Sequence Error Reporting Sequence Deployment View Infrastructure Level 1 Technical Infrastructure Security and Access Cross-cutting Concepts Domain Concepts Security Concepts Authentication and Authorization Input Validation Output Sanitization Development Concepts Test Strategy Release Process Configuration Concepts Rule Configuration Plugin System 09_architecture_decisions.adoc - Architecture Decisions Architecture Decisions ADR 1: Rule Base Class Design ADR-001-rule-base-class.adoc - Rule Base Class Design Decision ADR 1: Rule Base Class Design ADR 2: Finding Data Structure ADR-002-finding-data-structure.adoc - Finding Data Structure Decision ADR 2: Finding Data Structure ADR 3: Rule Implementation Strategy ADR-003-rule-implementation-strategy.adoc - Rule Implementation Strategy Decision ADR 3: Rule Implementation Strategy ADR 4: Test Strategy ADR-004-test-strategy.adoc - Test Strategy Decision ADR 4: Test Strategy ADR 5: Table Processing Strategy ADR-005-table-processing-strategy.adoc - Table Processing Strategy Decision ADR 5: Table Processing Strategy ADR 6: Severity Standardization ADR-006-severity-standardization.adoc - Severity Standardization Decision ADR 6: Severity Standardization ADR 7: Rule Registry Enhancement ADR-007-rule-registry-enhancement.adoc - Rule Registry Enhancement Decision ADR 7: Rule Registry Enhancement 10_quality_requirements.adoc - Quality Requirements Quality Requirements Quality Scenarios Performance Scenarios Reliability Scenarios Usability Scenarios Test Quality Scenarios Quality Tree Quality Metrics Test Quality Code Quality Performance Reliability 11_technical_risks.adoc - Technical Risks Technical Risks and Technical Debt Current Issues (December 2024) Test Failures Coverage Gaps Implementation Issues Risk Analysis Technical Debt Current Technical Debt Implementation Debt Planned Improvements Risk Matrix Mitigation Strategy Phase 1: Critical Issues (1-2 weeks) Phase 2: Important Improvements (2-3 weeks) Phase 3: Long-term Stability (3-4 weeks) Glossary AsciiDoc Linter Architecture Documentation Introduction and Goals Requirements Overview The AsciiDoc Linter is a tool designed to ensure consistent formatting and structure in AsciiDoc documents. It helps teams maintain high-quality documentation by enforcing style rules and best practices. Key requirements include: Validate AsciiDoc heading structure Ensure consistent formatting Provide clear error messages Easy integration into existing workflows Extensible rule system Quality Goals Priority Quality Goal Motivation 1 Extensibility The system must be easily extensible with new rules to accommodate different documentation standards and requirements. 2 Reliability The linter must provide consistent and accurate results to maintain user trust. 3 Usability Error messages must be clear and actionable, helping users fix documentation issues efficiently. 4 Performance The linter should process documents quickly to maintain a smooth workflow. 5 Maintainability The code must be well-structured and documented to facilitate future enhancements. Stakeholders Role/Name Contact Expectations Documentation Writers various * Clear error messages * Consistent results * Quick feedback Documentation Maintainers various * Configurable rules * Reliable validation * Integration with existing tools Development Team dev team * Extensible architecture * Good test coverage * Clear documentation Technical Writers various * Support for AsciiDoc best practices * Customizable rule sets * Batch processing capabilities Architecture Constraints Technical Constraints Constraint Description Background Python 3.8+ The system must run on Python 3.8 or higher Need for modern language features and type hints Platform Independence Must run on Windows, Linux, and macOS Support for all major development platforms No External Dependencies Core functionality should work without external libraries Easy installation and deployment Memory Footprint Should process documents with minimal memory usage Support for large documentation projects Organizational Constraints Constraint Description Background Open Source Project must be open source under MIT license Community involvement and transparency Documentation All code must be documented with docstrings Maintainability and community contribution Test Coverage Minimum 90% test coverage required Quality assurance and reliability Version Control Git-based development with feature branches Collaborative development process Conventions Convention Description Background Code Style Follow PEP 8 guidelines Python community standards Type Hints Use type hints throughout the code Code clarity and IDE support Commit Messages Follow conventional commits specification Clear change history Documentation Format Use AsciiDoc for all documentation Dogfooding our own tool System Scope and Context Business Context Technical Context Solution Strategy Quality Goals and Architectural Approaches Quality Goal Solution Approach Details Extensibility * Abstract base classes * Plugin architecture * Clear interfaces * New rules can be added by extending base classes * Plugin system allows external rule packages * Well-defined interfaces for rule implementation Reliability * Comprehensive testing * Strong typing * Defensive programming * High test coverage * Type hints throughout the code * Careful input validation Usability * Clear error messages * Context information * Configuration options * Detailed error descriptions * Line and column information * Configurable rule severity Performance * Efficient algorithms * Lazy loading * Caching * Line-by-line processing * Rules loaded on demand * Cache parsing results Maintainability * Clean architecture * SOLID principles * Documentation * Clear separation of concerns * Single responsibility principle * Comprehensive documentation Technology Decisions Technology Decision Rationale Python Primary implementation language * Strong standard library * Great text processing capabilities * Wide adoption in tooling Regular Expressions Pattern matching * Built into Python * Efficient for text processing * Well understood by developers YAML Configuration format * Human readable * Standard format * Good library support unittest Testing framework * Part of Python standard library * Well known to developers * Good IDE support Implementation Patterns Building Block View Level 1 - System Overview Level 2 - Core Components Level 3 - Rule Implementation Runtime View Document Processing Sequence Rule Loading Sequence Error Reporting Sequence Deployment View Infrastructure Level 1 Technical Infrastructure Security and Access Cross-cutting Concepts Domain Concepts Security Concepts Authentication and Authorization Package distribution secured via PyPI authentication Configuration files with restricted access Signed releases with GPG keys Input Validation Strict content validation Safe file handling Memory usage limits Output Sanitization Escaped error messages Safe file paths handling Controlled error reporting Development Concepts Test Strategy Release Process Configuration Concepts Rule Configuration rules: heading_hierarchy: enabled: true severity: error options: max_level: 6 heading_format: enabled: true severity: warning options: require_space: true require_capitalization: true Plugin System 09_architecture_decisions.adoc - Architecture Decisions Architecture Decisions This chapter contains all architecture decisions for the AsciiDoc Linter project. Each decision is documented in a separate file and included here. ADR 1: Rule Base Class Design ADR-001-rule-base-class.adoc - Rule Base Class Design Decision ADR 1: Rule Base Class Design Status Accepted Context We need a flexible and extensible way to implement different linting rules for AsciiDoc documents. Decision We will use an abstract base class Rule with a defined interface that all concrete rules must implement. Consequences Positive Consistent interface for all rules Easy to add new rules Clear separation of concerns Simplified testing through common interface Negative Additional abstraction layer Slight performance overhead ADR 2: Finding Data Structure ADR-002-finding-data-structure.adoc - Finding Data Structure Decision ADR 2: Finding Data Structure Status Accepted Context Rule violations need to be reported in a consistent and informative way. Decision We will use a Finding data class with fields for message, severity, position, rule ID, and context. Consequences Positive Structured error reporting Rich context for violations Consistent error format Negative More complex than simple string messages Requires more memory for storing findings ADR 3: Rule Implementation Strategy ADR-003-rule-implementation-strategy.adoc - Rule Implementation Strategy Decision ADR 3: Rule Implementation Strategy Status Accepted Context Rules need to process AsciiDoc content and identify violations efficiently. Decision Each rule will process the content line by line, using regular expressions for pattern matching. Consequences Positive Simple implementation Good performance for most cases Easy to understand and maintain Negative Limited context awareness May miss some complex patterns Regular expressions can become complex ADR 4: Test Strategy ADR-004-test-strategy.adoc - Test Strategy Decision ADR 4: Test Strategy Status Accepted Context Rules need to be thoroughly tested to ensure reliable operation. Decision Each rule will have its own test class with multiple test methods covering various scenarios. Consequences Positive High test coverage Clear test organization Easy to add new test cases Negative More maintenance effort Longer test execution time ADR 5: Table Processing Strategy ADR-005-table-processing-strategy.adoc - Table Processing Strategy Decision ADR 5: Table Processing Strategy Status Proposed Context Table processing in AsciiDoc documents requires complex parsing and validation: * Tables can contain various content types (text, lists, blocks) * Cell extraction needs to handle multi-line content * Column counting must be reliable * List detection in cells must be accurate Current implementation has issues: * Cell extraction produces incorrect results * List detection generates false positives * Column counting is unreliable Decision We will implement a new table processing strategy: Two-Pass Parsing First pass: Identify table boundaries and structure Second pass: Extract and validate cell content Cell Content Model Create a dedicated TableCell class Track content type (text, list, block) Maintain line number information List Detection Use state machine for list recognition Track list context across cell boundaries Validate list markers against AsciiDoc spec Column Management Count columns based on header row Validate all rows against header Handle empty cells explicitly Technical Details class TableCell: def __init__(self): self.content = [] self.content_type = None self.start_line = None self.end_line = None self.has_list = False self.list_level = 0 class TableRow: def __init__(self): self.cells = [] self.line_number = None self.is_header = False class TableProcessor: def first_pass(self, lines): # Identify table structure pass def second_pass(self, table_lines): # Extract cell content pass def detect_lists(self, cell): # Use state machine for list detection pass Consequences Positive More accurate cell extraction Reliable list detection Better error reporting Maintainable code structure Clear separation of concerns Negative More complex implementation Slightly higher memory usage Additional processing overhead More code to maintain Implementation Plan Phase 1: Core Structure Implement TableCell and TableRow classes Basic two-pass parsing Unit tests for basic functionality Phase 2: Content Processing List detection state machine Content type recognition Error context collection Phase 3: Validation Column counting Structure validation Comprehensive test suite Validation Success criteria: * All current table-related tests pass * Cell extraction matches expected results * List detection has no false positives * Column counting is accurate * Memory usage remains within limits Related Diagrams ADR 6: Severity Standardization ADR-006-severity-standardization.adoc - Severity Standardization Decision ADR 6: Severity Standardization Status Proposed Context Current implementation has inconsistent severity level handling: * Mixed case usage (ERROR vs error) * Inconsistent severity levels across rules * No clear guidelines for severity assignment Decision We will standardize severity handling: Severity Levels ERROR: Issues that must be fixed WARNING: Issues that should be reviewed INFO: Suggestions for improvement Implementation Use lowercase for internal representation Provide case-sensitive display methods Add severity level documentation Migration Update all existing rules Add validation in base class Update tests to use new standard Consequences Positive Consistent severity handling Clear guidelines for new rules Better user experience Negative Need to update existing code Potential backward compatibility issues Related Diagrams ADR 7: Rule Registry Enhancement ADR-007-rule-registry-enhancement.adoc - Rule Registry Enhancement Decision ADR 7: Rule Registry Enhancement Status Proposed Context Current rule registry implementation lacks: * Test coverage * Clear registration mechanism * Version handling * Rule dependency management Decision We will enhance the rule registry: Registration Add explicit registration decorator Support rule dependencies Add version information Management Add rule enabling/disabling Support rule groups Add configuration validation Testing Add comprehensive test suite Test all registration scenarios Test configuration handling Consequences Positive Better rule management Clear registration process Improved testability Negative More complex implementation Additional maintenance overhead Related Diagrams 10_quality_requirements.adoc - Quality Requirements Quality Requirements Quality Scenarios Performance Scenarios Scenario Stimulus Response Priority Fast Document Processing Process 1000-line document Complete in &lt; 1 second High Multiple File Processing Process 100 documents Complete in &lt; 10 seconds Medium Memory Usage Process large document (10MB) Use &lt; 100MB RAM High Startup Time Launch linter Ready in &lt; 0.5 seconds Medium Table Processing Process document with 100 tables Complete in &lt; 2 seconds High Reliability Scenarios Scenario Stimulus Response Priority Error Recovery Invalid input file Clear error message, continue with next file High Configuration Error Invalid rule configuration Detailed error message, use defaults High Plugin Failure Plugin crashes Isolate failure, continue with other rules Medium Resource Exhaustion System low on memory Graceful shutdown, save progress Medium Table Content Error Invalid table structure Clear error message with line numbers and context High List in Table Undeclared list in table cell Detect and report with context High Usability Scenarios Scenario Stimulus Response Priority Clear Error Messages Rule violation found Show file, line, and actionable message High Configuration Change rule settings Take effect without restart Medium Integration Use in CI pipeline Exit code reflects success/failure High Documentation Look up rule details Find explanation within 30 seconds Medium Table Error Context Table formatting error Show table context and specific cell High Test Quality Scenarios Scenario Stimulus Response Priority Test Coverage Add new feature Maintain &gt;90% coverage High Test Success Rate Run test suite &gt;95% tests passing High Edge Case Coverage Complex document structure All edge cases tested Medium Performance Tests Run benchmark suite Complete in &lt; 5 minutes Medium Quality Tree Quality Metrics Test Quality Test Coverage: &gt;90% for all modules Test Success Rate: &gt;95% Edge Case Coverage: All identified edge cases have tests Code Quality Maintainability Index: &gt;80 Cyclomatic Complexity: &lt;10 per method Documentation Coverage: &gt;80% Performance Processing Speed: &lt;1ms per line Memory Usage: &lt;100MB Table Processing: &lt;20ms per table Reliability False Positive Rate: &lt;1% Error Recovery: 100% of known error cases Plugin Stability: No impact on core functionality :jbake-status: published :jbake-order: 11 :jbake-type: page_toc :jbake-menu: arc42 :jbake-title: Technical Risks and Technical Debt 11_technical_risks.adoc - Technical Risks Technical Risks and Technical Debt Current Issues (December 2024) Test Failures 3 failed tests in table processing Issues with cell extraction and list detection Impact on table validation reliability Coverage Gaps rules.py: 0% coverage reporter.py: 85% coverage block_rules.py: 89% coverage Implementation Issues Inconsistent severity case handling Missing rule_id attribute in base class Table content validation problems Risk Analysis Risk Description Impact Probability Mitigation Table Processing Errors Table content validation unreliable High High * Fix cell extraction * Improve list detection * Add comprehensive tests Test Coverage Gaps Critical modules lack tests High Medium * Add tests for rules.py * Improve reporter coverage * Document test scenarios Performance Degradation Rule processing becomes slow with many rules High Medium * Profile rule execution * Implement rule caching * Optimize core algorithms Memory Leaks Long-running processes accumulate memory High Low * Regular memory profiling * Automated testing * Resource cleanup False Positives Rules report incorrect violations Medium High * Extensive test cases * User feedback system * Rule configuration options Plugin Conflicts Custom rules interfere with core rules Medium Medium * Plugin isolation * Version compatibility checks * Clear plugin API Technical Debt Current Technical Debt Area Description Impact Priority Table Processing Cell extraction and list detection issues High High Test Coverage rules.py and reporter.py need tests High High Core Architecture Inconsistent severity handling Medium High Documentation Some advanced features poorly documented Medium Medium Error Handling Some error cases not specifically handled High High Configuration Hard-coded values that should be configurable Low Low Implementation Debt Component Issue Impact Priority TableContentRule Cell extraction incorrect High High TableContentRule List detection problems High High Rule Base Class Missing rule_id attribute Medium High Severity Handling Inconsistent case usage Medium High rules.py No test coverage High High Planned Improvements Risk Matrix Mitigation Strategy Phase 1: Critical Issues (1-2 weeks) Fix table processing Add missing tests Standardize severity handling Phase 2: Important Improvements (2-3 weeks) Improve documentation Enhance error handling Add configuration options Phase 3: Long-term Stability (3-4 weeks) Performance optimization Memory management Plugin architecture improvements :jbake-status: published :jbake-order: 12 :jbake-type: page_toc :jbake-menu: arc42 :jbake-title: Glossary Glossary Term Definition Additional Information AsciiDoc Lightweight markup language for documentation Similar to Markdown, but with more features for technical documentation Linter Tool that analyzes source code or text for potential errors Focuses on style, format, and structure issues Rule Individual check that validates specific aspects Can be enabled/disabled and configured Finding Result of a rule check indicating a potential issue Contains message, severity, and location information Severity Importance level of a finding ERROR, WARNING, or INFO Position Location in a document where an issue was found Contains line and optional column information Plugin Extension that adds additional functionality Can provide custom rules and configurations CI/CD Continuous Integration/Continuous Deployment Automated build, test, and deployment process PyPI Python Package Index Central repository for Python packages Virtual Environment Isolated Python runtime environment Manages project-specific dependencies Type Hints Python type annotations Helps with code understanding and static analysis Unit Test Test of individual components Ensures correct behavior of specific functions Integration Test Test of component interactions Verifies system behavior as a whole Coverage Measure of code tested by automated tests Usually expressed as percentage Technical Debt Development shortcuts that need future attention Balance between quick delivery and maintainability "
},

{
    "id": 2,
    "uri": "arc42/06_runtime_view.html",
    "menu": "arc42",
    "title": "Runtime View",
    "text": " Table of Contents Runtime View Document Processing Sequence Rule Loading Sequence Error Reporting Sequence Runtime View Document Processing Sequence Rule Loading Sequence Error Reporting Sequence "
},

{
    "id": 3,
    "uri": "arc42/05_building_block_view.html",
    "menu": "arc42",
    "title": "Building Block View",
    "text": " Table of Contents Building Block View Level 1 - System Overview Level 2 - Core Components Level 3 - Rule Implementation Building Block View Level 1 - System Overview Level 2 - Core Components Level 3 - Rule Implementation "
},

{
    "id": 4,
    "uri": "arc42/01_introduction_and_goals.html",
    "menu": "arc42",
    "title": "Introduction and Goals",
    "text": " Table of Contents Introduction and Goals Requirements Overview Quality Goals Stakeholders Introduction and Goals Requirements Overview The AsciiDoc Linter is a tool designed to ensure consistent formatting and structure in AsciiDoc documents. It helps teams maintain high-quality documentation by enforcing style rules and best practices. Key requirements include: Validate AsciiDoc heading structure Ensure consistent formatting Provide clear error messages Easy integration into existing workflows Extensible rule system Quality Goals Priority Quality Goal Motivation 1 Extensibility The system must be easily extensible with new rules to accommodate different documentation standards and requirements. 2 Reliability The linter must provide consistent and accurate results to maintain user trust. 3 Usability Error messages must be clear and actionable, helping users fix documentation issues efficiently. 4 Performance The linter should process documents quickly to maintain a smooth workflow. 5 Maintainability The code must be well-structured and documented to facilitate future enhancements. Stakeholders Role/Name Contact Expectations Documentation Writers various * Clear error messages * Consistent results * Quick feedback Documentation Maintainers various * Configurable rules * Reliable validation * Integration with existing tools Development Team dev team * Extensible architecture * Good test coverage * Clear documentation Technical Writers various * Support for AsciiDoc best practices * Customizable rule sets * Batch processing capabilities "
},

{
    "id": 5,
    "uri": "arc42/11_technical_risks.html",
    "menu": "arc42",
    "title": "Technical Risks and Technical Debt",
    "text": " Table of Contents 11_technical_risks.adoc - Technical Risks Technical Risks and Technical Debt Current Issues (December 2024) Risk Analysis Technical Debt Risk Matrix Mitigation Strategy 11_technical_risks.adoc - Technical Risks Technical Risks and Technical Debt Current Issues (December 2024) Test Failures 3 failed tests in table processing Issues with cell extraction and list detection Impact on table validation reliability Coverage Gaps rules.py: 0% coverage reporter.py: 85% coverage block_rules.py: 89% coverage Implementation Issues Inconsistent severity case handling Missing rule_id attribute in base class Table content validation problems Risk Analysis Risk Description Impact Probability Mitigation Table Processing Errors Table content validation unreliable High High * Fix cell extraction * Improve list detection * Add comprehensive tests Test Coverage Gaps Critical modules lack tests High Medium * Add tests for rules.py * Improve reporter coverage * Document test scenarios Performance Degradation Rule processing becomes slow with many rules High Medium * Profile rule execution * Implement rule caching * Optimize core algorithms Memory Leaks Long-running processes accumulate memory High Low * Regular memory profiling * Automated testing * Resource cleanup False Positives Rules report incorrect violations Medium High * Extensive test cases * User feedback system * Rule configuration options Plugin Conflicts Custom rules interfere with core rules Medium Medium * Plugin isolation * Version compatibility checks * Clear plugin API Technical Debt Current Technical Debt Area Description Impact Priority Table Processing Cell extraction and list detection issues High High Test Coverage rules.py and reporter.py need tests High High Core Architecture Inconsistent severity handling Medium High Documentation Some advanced features poorly documented Medium Medium Error Handling Some error cases not specifically handled High High Configuration Hard-coded values that should be configurable Low Low Implementation Debt Component Issue Impact Priority TableContentRule Cell extraction incorrect High High TableContentRule List detection problems High High Rule Base Class Missing rule_id attribute Medium High Severity Handling Inconsistent case usage Medium High rules.py No test coverage High High Planned Improvements Risk Matrix Mitigation Strategy Phase 1: Critical Issues (1-2 weeks) Fix table processing Add missing tests Standardize severity handling Phase 2: Important Improvements (2-3 weeks) Improve documentation Enhance error handling Add configuration options Phase 3: Long-term Stability (3-4 weeks) Performance optimization Memory management Plugin architecture improvements "
},

{
    "id": 6,
    "uri": "arc42/10_quality_requirements.html",
    "menu": "arc42",
    "title": "Quality Requirements",
    "text": " Table of Contents 10_quality_requirements.adoc - Quality Requirements Quality Requirements Quality Scenarios Quality Tree Quality Metrics 10_quality_requirements.adoc - Quality Requirements Quality Requirements Quality Scenarios Performance Scenarios Scenario Stimulus Response Priority Fast Document Processing Process 1000-line document Complete in &lt; 1 second High Multiple File Processing Process 100 documents Complete in &lt; 10 seconds Medium Memory Usage Process large document (10MB) Use &lt; 100MB RAM High Startup Time Launch linter Ready in &lt; 0.5 seconds Medium Table Processing Process document with 100 tables Complete in &lt; 2 seconds High Reliability Scenarios Scenario Stimulus Response Priority Error Recovery Invalid input file Clear error message, continue with next file High Configuration Error Invalid rule configuration Detailed error message, use defaults High Plugin Failure Plugin crashes Isolate failure, continue with other rules Medium Resource Exhaustion System low on memory Graceful shutdown, save progress Medium Table Content Error Invalid table structure Clear error message with line numbers and context High List in Table Undeclared list in table cell Detect and report with context High Usability Scenarios Scenario Stimulus Response Priority Clear Error Messages Rule violation found Show file, line, and actionable message High Configuration Change rule settings Take effect without restart Medium Integration Use in CI pipeline Exit code reflects success/failure High Documentation Look up rule details Find explanation within 30 seconds Medium Table Error Context Table formatting error Show table context and specific cell High Test Quality Scenarios Scenario Stimulus Response Priority Test Coverage Add new feature Maintain &gt;90% coverage High Test Success Rate Run test suite &gt;95% tests passing High Edge Case Coverage Complex document structure All edge cases tested Medium Performance Tests Run benchmark suite Complete in &lt; 5 minutes Medium Quality Tree Quality Metrics Test Quality Test Coverage: &gt;90% for all modules Test Success Rate: &gt;95% Edge Case Coverage: All identified edge cases have tests Code Quality Maintainability Index: &gt;80 Cyclomatic Complexity: &lt;10 per method Documentation Coverage: &gt;80% Performance Processing Speed: &lt;1ms per line Memory Usage: &lt;100MB Table Processing: &lt;20ms per table Reliability False Positive Rate: &lt;1% Error Recovery: 100% of known error cases Plugin Stability: No impact on core functionality "
},

{
    "id": 7,
    "uri": "arc42/12_glossary.html",
    "menu": "arc42",
    "title": "Glossary",
    "text": " Table of Contents Glossary Glossary Term Definition Additional Information AsciiDoc Lightweight markup language for documentation Similar to Markdown, but with more features for technical documentation Linter Tool that analyzes source code or text for potential errors Focuses on style, format, and structure issues Rule Individual check that validates specific aspects Can be enabled/disabled and configured Finding Result of a rule check indicating a potential issue Contains message, severity, and location information Severity Importance level of a finding ERROR, WARNING, or INFO Position Location in a document where an issue was found Contains line and optional column information Plugin Extension that adds additional functionality Can provide custom rules and configurations CI/CD Continuous Integration/Continuous Deployment Automated build, test, and deployment process PyPI Python Package Index Central repository for Python packages Virtual Environment Isolated Python runtime environment Manages project-specific dependencies Type Hints Python type annotations Helps with code understanding and static analysis Unit Test Test of individual components Ensures correct behavior of specific functions Integration Test Test of component interactions Verifies system behavior as a whole Coverage Measure of code tested by automated tests Usually expressed as percentage Technical Debt Development shortcuts that need future attention Balance between quick delivery and maintainability "
},

{
    "id": 8,
    "uri": "arc42/08_concepts.html",
    "menu": "arc42",
    "title": "Cross-cutting Concepts",
    "text": " Table of Contents Cross-cutting Concepts Domain Concepts Security Concepts Development Concepts Configuration Concepts Cross-cutting Concepts Domain Concepts Security Concepts Authentication and Authorization Package distribution secured via PyPI authentication Configuration files with restricted access Signed releases with GPG keys Input Validation Strict content validation Safe file handling Memory usage limits Output Sanitization Escaped error messages Safe file paths handling Controlled error reporting Development Concepts Test Strategy Release Process Configuration Concepts Rule Configuration rules: heading_hierarchy: enabled: true severity: error options: max_level: 6 heading_format: enabled: true severity: warning options: require_space: true require_capitalization: true Plugin System "
},

{
    "id": 9,
    "uri": "arc42/07_deployment_view.html",
    "menu": "arc42",
    "title": "Deployment View",
    "text": " Table of Contents Deployment View Infrastructure Level 1 Technical Infrastructure Security and Access Deployment View Infrastructure Level 1 Technical Infrastructure Security and Access "
},

{
    "id": 10,
    "uri": "arc42/03_system_scope_and_context.html",
    "menu": "arc42",
    "title": "System Scope and Context",
    "text": " Table of Contents System Scope and Context Business Context Technical Context System Scope and Context Business Context Technical Context "
},

{
    "id": 11,
    "uri": "arc42/04_solution_strategy.html",
    "menu": "arc42",
    "title": "Solution Strategy",
    "text": " Table of Contents Solution Strategy Quality Goals and Architectural Approaches Technology Decisions Implementation Patterns Solution Strategy Quality Goals and Architectural Approaches Quality Goal Solution Approach Details Extensibility * Abstract base classes * Plugin architecture * Clear interfaces * New rules can be added by extending base classes * Plugin system allows external rule packages * Well-defined interfaces for rule implementation Reliability * Comprehensive testing * Strong typing * Defensive programming * High test coverage * Type hints throughout the code * Careful input validation Usability * Clear error messages * Context information * Configuration options * Detailed error descriptions * Line and column information * Configurable rule severity Performance * Efficient algorithms * Lazy loading * Caching * Line-by-line processing * Rules loaded on demand * Cache parsing results Maintainability * Clean architecture * SOLID principles * Documentation * Clear separation of concerns * Single responsibility principle * Comprehensive documentation Technology Decisions Technology Decision Rationale Python Primary implementation language * Strong standard library * Great text processing capabilities * Wide adoption in tooling Regular Expressions Pattern matching * Built into Python * Efficient for text processing * Well understood by developers YAML Configuration format * Human readable * Standard format * Good library support unittest Testing framework * Part of Python standard library * Well known to developers * Good IDE support Implementation Patterns "
},

{
    "id": 12,
    "uri": "arc42/09_architecture_decisions.html",
    "menu": "arc42",
    "title": "Architecture Decisions",
    "text": " Table of Contents 09_architecture_decisions.adoc - Architecture Decisions Architecture Decisions ADR 1: Rule Base Class Design ADR-001-rule-base-class.adoc - Rule Base Class Design Decision ADR 2: Finding Data Structure ADR-002-finding-data-structure.adoc - Finding Data Structure Decision ADR 3: Rule Implementation Strategy ADR-003-rule-implementation-strategy.adoc - Rule Implementation Strategy Decision ADR 4: Test Strategy ADR-004-test-strategy.adoc - Test Strategy Decision ADR 5: Table Processing Strategy ADR-005-table-processing-strategy.adoc - Table Processing Strategy Decision ADR 6: Severity Standardization ADR-006-severity-standardization.adoc - Severity Standardization Decision ADR 7: Rule Registry Enhancement ADR-007-rule-registry-enhancement.adoc - Rule Registry Enhancement Decision 09_architecture_decisions.adoc - Architecture Decisions Architecture Decisions This chapter contains all architecture decisions for the AsciiDoc Linter project. Each decision is documented in a separate file and included here. ADR 1: Rule Base Class Design ADR-001-rule-base-class.adoc - Rule Base Class Design Decision ADR 1: Rule Base Class Design Status Accepted Context We need a flexible and extensible way to implement different linting rules for AsciiDoc documents. Decision We will use an abstract base class Rule with a defined interface that all concrete rules must implement. Consequences Positive Consistent interface for all rules Easy to add new rules Clear separation of concerns Simplified testing through common interface Negative Additional abstraction layer Slight performance overhead ADR 2: Finding Data Structure ADR-002-finding-data-structure.adoc - Finding Data Structure Decision ADR 2: Finding Data Structure Status Accepted Context Rule violations need to be reported in a consistent and informative way. Decision We will use a Finding data class with fields for message, severity, position, rule ID, and context. Consequences Positive Structured error reporting Rich context for violations Consistent error format Negative More complex than simple string messages Requires more memory for storing findings ADR 3: Rule Implementation Strategy ADR-003-rule-implementation-strategy.adoc - Rule Implementation Strategy Decision ADR 3: Rule Implementation Strategy Status Accepted Context Rules need to process AsciiDoc content and identify violations efficiently. Decision Each rule will process the content line by line, using regular expressions for pattern matching. Consequences Positive Simple implementation Good performance for most cases Easy to understand and maintain Negative Limited context awareness May miss some complex patterns Regular expressions can become complex ADR 4: Test Strategy ADR-004-test-strategy.adoc - Test Strategy Decision ADR 4: Test Strategy Status Accepted Context Rules need to be thoroughly tested to ensure reliable operation. Decision Each rule will have its own test class with multiple test methods covering various scenarios. Consequences Positive High test coverage Clear test organization Easy to add new test cases Negative More maintenance effort Longer test execution time ADR 5: Table Processing Strategy ADR-005-table-processing-strategy.adoc - Table Processing Strategy Decision ADR 5: Table Processing Strategy Status Proposed Context Table processing in AsciiDoc documents requires complex parsing and validation: * Tables can contain various content types (text, lists, blocks) * Cell extraction needs to handle multi-line content * Column counting must be reliable * List detection in cells must be accurate Current implementation has issues: * Cell extraction produces incorrect results * List detection generates false positives * Column counting is unreliable Decision We will implement a new table processing strategy: Two-Pass Parsing First pass: Identify table boundaries and structure Second pass: Extract and validate cell content Cell Content Model Create a dedicated TableCell class Track content type (text, list, block) Maintain line number information List Detection Use state machine for list recognition Track list context across cell boundaries Validate list markers against AsciiDoc spec Column Management Count columns based on header row Validate all rows against header Handle empty cells explicitly Technical Details class TableCell: def __init__(self): self.content = [] self.content_type = None self.start_line = None self.end_line = None self.has_list = False self.list_level = 0 class TableRow: def __init__(self): self.cells = [] self.line_number = None self.is_header = False class TableProcessor: def first_pass(self, lines): # Identify table structure pass def second_pass(self, table_lines): # Extract cell content pass def detect_lists(self, cell): # Use state machine for list detection pass Consequences Positive More accurate cell extraction Reliable list detection Better error reporting Maintainable code structure Clear separation of concerns Negative More complex implementation Slightly higher memory usage Additional processing overhead More code to maintain Implementation Plan Phase 1: Core Structure Implement TableCell and TableRow classes Basic two-pass parsing Unit tests for basic functionality Phase 2: Content Processing List detection state machine Content type recognition Error context collection Phase 3: Validation Column counting Structure validation Comprehensive test suite Validation Success criteria: * All current table-related tests pass * Cell extraction matches expected results * List detection has no false positives * Column counting is accurate * Memory usage remains within limits Related Diagrams ADR 6: Severity Standardization ADR-006-severity-standardization.adoc - Severity Standardization Decision ADR 6: Severity Standardization Status Proposed Context Current implementation has inconsistent severity level handling: * Mixed case usage (ERROR vs error) * Inconsistent severity levels across rules * No clear guidelines for severity assignment Decision We will standardize severity handling: Severity Levels ERROR: Issues that must be fixed WARNING: Issues that should be reviewed INFO: Suggestions for improvement Implementation Use lowercase for internal representation Provide case-sensitive display methods Add severity level documentation Migration Update all existing rules Add validation in base class Update tests to use new standard Consequences Positive Consistent severity handling Clear guidelines for new rules Better user experience Negative Need to update existing code Potential backward compatibility issues Related Diagrams ADR 7: Rule Registry Enhancement ADR-007-rule-registry-enhancement.adoc - Rule Registry Enhancement Decision ADR 7: Rule Registry Enhancement Status Proposed Context Current rule registry implementation lacks: * Test coverage * Clear registration mechanism * Version handling * Rule dependency management Decision We will enhance the rule registry: Registration Add explicit registration decorator Support rule dependencies Add version information Management Add rule enabling/disabling Support rule groups Add configuration validation Testing Add comprehensive test suite Test all registration scenarios Test configuration handling Consequences Positive Better rule management Clear registration process Improved testability Negative More complex implementation Additional maintenance overhead Related Diagrams "
},

{
    "id": 13,
    "uri": "arc42/02_architecture_constraints.html",
    "menu": "arc42",
    "title": "Architecture Constraints",
    "text": " Table of Contents Architecture Constraints Technical Constraints Organizational Constraints Conventions Architecture Constraints Technical Constraints Constraint Description Background Python 3.8+ The system must run on Python 3.8 or higher Need for modern language features and type hints Platform Independence Must run on Windows, Linux, and macOS Support for all major development platforms No External Dependencies Core functionality should work without external libraries Easy installation and deployment Memory Footprint Should process documents with minimal memory usage Support for large documentation projects Organizational Constraints Constraint Description Background Open Source Project must be open source under MIT license Community involvement and transparency Documentation All code must be documented with docstrings Maintainability and community contribution Test Coverage Minimum 90% test coverage required Quality assurance and reliability Version Control Git-based development with feature branches Collaborative development process Conventions Convention Description Background Code Style Follow PEP 8 guidelines Python community standards Type Hints Use type hints throughout the code Code clarity and IDE support Commit Messages Follow conventional commits specification Clear change history Documentation Format Use AsciiDoc for all documentation Dogfooding our own tool "
},

{
    "id": 14,
    "uri": "manual/testing.html",
    "menu": "manual",
    "title": "Testing Strategy and Guide",
    "text": " Table of Contents Testing Strategy and Guide .1. Test Strategy .2. Test Implementation .3. Running Tests .4. Test Maintenance .5. Appendix .6. References Testing Strategy and Guide .1. Test Strategy .1.1. Goals and Objectives The testing strategy for the AsciiDoc Linter aims to: Ensure reliable detection of AsciiDoc formatting issues Prevent false positives that could frustrate users Maintain high code quality through comprehensive testing Enable safe refactoring through good test coverage Support rapid development through automated testing .1.2. Test Levels Unit Tests Test individual rules in isolation Verify rule logic and error detection Cover edge cases and special scenarios Test configuration options Integration Tests Test interaction between parser and rules Verify correct document processing Test CLI interface and options Test reporter output formats System Tests End-to-end testing of the linter Test with real AsciiDoc documents Verify correct error reporting Test performance with large documents .1.3. Test Coverage Goals Component Target Coverage Current Coverage Core (parser, linter) 90% 0% Rules 95% 88% CLI 80% 0% Reporter 85% 0% Overall 90% 61% .1.4. Quality Metrics Line Coverage: Minimum 90% Branch Coverage: Minimum 85% Mutation Score: Minimum 80% Test Success Rate: 100% No known bugs in production .2. Test Implementation .2.1. Test Organization tests/  __init__.py  rules/ # Rule-specific tests   __init__.py   test_heading_rules.py   test_block_rules.py   test_image_rules.py   test_whitespace_rules.py  integration/ # Integration tests   __init__.py   test_parser_rules.py   test_cli_reporter.py  system/ # System tests   __init__.py   test_large_docs.py   test_real_projects.py  test_cli.py # CLI tests  test_parser.py # Parser tests  test_reporter.py # Reporter tests  test_linter.py # Core linter tests .2.2. Test Patterns Rule Tests def test_rule_pattern(self): # Given: Setup test data and context content = \"test content\" rule = TestRule(config) # When: Execute the rule findings = rule.check(content) # Then: Verify results assert_findings(findings) Integration Tests def test_integration_pattern(self): # Given: Setup test environment doc = create_test_document() linter = setup_linter() # When: Process document results = linter.process(doc) # Then: Verify complete workflow verify_results(results) .2.3. Test Data Management Test Documents Maintain a collection of test documents Include both valid and invalid examples Document the purpose of each test file Version control test data Test Fixtures Use pytest fixtures for common setup Share test data between related tests Clean up test environment after each test Mock external dependencies .3. Running Tests .3.1. Local Development # Run all tests python run_tests.py # Run with coverage coverage run -m pytest coverage report coverage html # Run specific test categories pytest tests/rules/ pytest tests/integration/ pytest tests/system/ .3.2. Continuous Integration GitHub Actions Workflow name: Test Suite on: [push, pull_request] jobs: test: runs-on: ubuntu-latest strategy: matrix: python-version: [3.8, 3.9, \"3.10\"] steps: - uses: actions/checkout@v2 - name: Set up Python uses: actions/setup-python@v2 with: python-version: ${{ matrix.python-version }} - name: Install dependencies run: | python -m pip install --upgrade pip pip install -r requirements.txt - name: Run tests run: | coverage run -m pytest coverage report coverage xml - name: Upload coverage uses: codecov/codecov-action@v2 .4. Test Maintenance .4.1. Regular Activities Review test coverage reports weekly Update tests for new features Refactor tests when needed Review test performance Update test documentation .4.2. Quality Checks Run mutation testing monthly Review test maintainability Check for flaky tests Verify test isolation .5. Appendix .5.1. Test Templates Unit Test Template class TestRuleName(unittest.TestCase): def setUp(self): \"\"\"Setup test environment\"\"\" self.rule = RuleUnderTest() def test_valid_case(self): \"\"\"Test with valid input\"\"\" # Given content = \"valid content\" # When findings = self.rule.check(content) # Then self.assertEqual(len(findings), 0) def test_invalid_case(self): \"\"\"Test with invalid input\"\"\" # Given content = \"invalid content\" # When findings = self.rule.check(content) # Then self.assertEqual(len(findings), 1) self.assertEqual(findings[0].severity, Severity.ERROR) .5.2. Test Checklists New Feature Checklist &#10063; Unit tests written &#10063; Integration tests updated &#10063; System tests verified &#10063; Coverage goals met &#10063; Documentation updated Test Review Checklist &#10063; Tests follow patterns &#10063; Coverage adequate &#10063; Edge cases covered &#10063; Error cases tested &#10063; Documentation clear .6. References Pytest Documentation Coverage.py Documentation Codecov GitHub Action "
},

{
    "id": 15,
    "uri": "manual/index.html",
    "menu": "manual",
    "title": "AsciiDoc Linter Manual",
    "text": " Table of Contents AsciiDoc Linter Manual Introduction Development Guide Testing Strategy and Guide .1. Usage Guide .2. AsciiDoc Linter Rules AsciiDoc Linter Manual Introduction About the Project AsciiDoc Linter is a Python-based tool designed to help maintain high-quality AsciiDoc documentation. It checks your AsciiDoc files for common issues and style violations, helping teams maintain consistent documentation standards. As part of the docToolchain project ( https://doctoolchain.org ), it integrates well with existing documentation workflows. Key Features Heading structure validation Proper hierarchy (no skipped levels) Consistent formatting Single top-level heading Block validation Proper block termination Consistent spacing Whitespace consistency Line spacing List formatting Tab detection Image validation Attribute checking File existence verification Multiple output formats (console, JSON, HTML) Project Goals Improve documentation quality through automated checks Enforce consistent styling across documentation Reduce manual review effort Catch common mistakes early in the documentation process Support documentation as code practices Integrate with existing documentation toolchains Technical Overview Table 1. Technology Stack Component Description Language Python 3.8+ Testing unittest framework Documentation AsciiDoc Configuration YAML/JSON (planned) Getting Started Prerequisites Python 3.8 or higher Git (for installation) Installation Direct installation via pip is planned for future releases. Currently, installation is done via git clone. # Clone the repository git clone https://github.com/docToolchain/asciidoc-linter.git # Navigate to the project directory cd asciidoc-linter # Install the package pip install . Basic Usage # Check a single file asciidoc-lint document.adoc # Check multiple files asciidoc-lint doc1.adoc doc2.adoc # Get help asciidoc-lint --help Current Status Implemented Features Core linting engine Basic rule set (headings, blocks, whitespace, images) Command-line interface Multiple output formats Planned Features Configuration system (YAML/JSON) Additional rule sets (tables, links, cross-references) Direct installation via pip IDE integration Git pre-commit hooks Development Guide Setting Up Development Environment Clone the Repository git clone https://github.com/docToolchain/asciidoc-linter.git cd asciidoc-linter Create Virtual Environment python -m venv venv source venv/bin/activate # On Windows: venv\\Scripts\\activate pip install -e . Project Structure asciidoc-linter/  asciidoc_linter/ # Main package   __init__.py   cli.py # Command line interface   rules/ # Rule implementations    __init__.py    base.py # Base classes for rules    heading_rules.py    block_rules.py    whitespace_rules.py    image_rules.py   parser.py # AsciiDoc parser   reporter.py # Output formatters  tests/ # Test files   rules/ # Rule-specific tests  docs/ # Documentation  README.adoc Current Implementation Status Implemented Features Core rule engine with base classes Rule implementations: Heading rules (hierarchy, format, multiple top-level) Block rules (termination, spacing) Whitespace rules (spacing, formatting) Image rules (attributes, file verification) Basic command line interface Multiple output formats (console, JSON, HTML) Comprehensive test suite Planned Features Configuration system (YAML/JSON) Rule enabling/disabling Severity customization Custom rule parameters Additional rule types IDE integration Git hooks Adding New Rules Rule Implementation Steps Create a new rule class: from .base import Rule, Finding, Severity, Position class MyNewRule(Rule): \"\"\" RULE_ID: Short description. Detailed explanation of what the rule checks. \"\"\" def __init__(self): super().__init__() self.id = \"RULE_ID\" @property def description(self) -&gt; str: return \"Description of what this rule checks\" def check(self, content: str) -&gt; List[Finding]: findings = [] # Implementation here return findings Add tests for the rule: class TestMyNewRule(unittest.TestCase): def setUp(self): self.rule = MyNewRule() def test_valid_case(self): content = \"Valid content\" findings = self.rule.check(content) self.assertEqual(len(findings), 0) def test_invalid_case(self): content = \"Invalid content\" findings = self.rule.check(content) self.assertEqual(len(findings), 1) self.assertEqual(findings[0].rule_id, \"RULE_ID\") Register the rule in the linter Update documentation Rule Guidelines Clear rule IDs and descriptions Meaningful error messages Proper severity levels Contextual information in findings Comprehensive test cases Documentation with examples Code Style Python Guidelines Follow PEP 8 Use type hints Write docstrings (Google style) Keep functions focused and testable Maximum line length: 100 characters Use meaningful variable names Documentation Guidelines Use AsciiDoc format Include examples for all features Explain error messages Document configuration options Keep README.adoc up to date Testing Running Tests # Run all tests python run_tests.py # Run specific test file python -m unittest tests/rules/test_heading_rules.py # Run specific test case python -m unittest tests.rules.test_heading_rules.TestHeadingHierarchyRule Test Guidelines Write tests for all new features Include both positive and negative test cases Test edge cases Maintain high test coverage Use meaningful test names Pull Request Process Create feature branch Implement changes Add/update tests Update documentation Run full test suite Submit PR Release Process Update version number in init .py Update changelog Run full test suite Create release notes Tag release Build and publish Getting Help GitHub Issues: https://github.com/docToolchain/asciidoc-linter/issues Project Wiki: https://github.com/docToolchain/asciidoc-linter/wiki docToolchain Community: https://doctoolchain.org/community Testing Strategy and Guide ..1. Test Strategy Goals and Objectives The testing strategy for the AsciiDoc Linter aims to: Ensure reliable detection of AsciiDoc formatting issues Prevent false positives that could frustrate users Maintain high code quality through comprehensive testing Enable safe refactoring through good test coverage Support rapid development through automated testing Test Levels Unit Tests Test individual rules in isolation Verify rule logic and error detection Cover edge cases and special scenarios Test configuration options Integration Tests Test interaction between parser and rules Verify correct document processing Test CLI interface and options Test reporter output formats System Tests End-to-end testing of the linter Test with real AsciiDoc documents Verify correct error reporting Test performance with large documents Test Coverage Goals Component Target Coverage Current Coverage Core (parser, linter) 90% 0% Rules 95% 88% CLI 80% 0% Reporter 85% 0% Overall 90% 61% Quality Metrics Line Coverage: Minimum 90% Branch Coverage: Minimum 85% Mutation Score: Minimum 80% Test Success Rate: 100% No known bugs in production ..2. Test Implementation Test Organization tests/  __init__.py  rules/ # Rule-specific tests   __init__.py   test_heading_rules.py   test_block_rules.py   test_image_rules.py   test_whitespace_rules.py  integration/ # Integration tests   __init__.py   test_parser_rules.py   test_cli_reporter.py  system/ # System tests   __init__.py   test_large_docs.py   test_real_projects.py  test_cli.py # CLI tests  test_parser.py # Parser tests  test_reporter.py # Reporter tests  test_linter.py # Core linter tests Test Patterns Rule Tests def test_rule_pattern(self): # Given: Setup test data and context content = \"test content\" rule = TestRule(config) # When: Execute the rule findings = rule.check(content) # Then: Verify results assert_findings(findings) Integration Tests def test_integration_pattern(self): # Given: Setup test environment doc = create_test_document() linter = setup_linter() # When: Process document results = linter.process(doc) # Then: Verify complete workflow verify_results(results) Test Data Management Test Documents Maintain a collection of test documents Include both valid and invalid examples Document the purpose of each test file Version control test data Test Fixtures Use pytest fixtures for common setup Share test data between related tests Clean up test environment after each test Mock external dependencies ..3. Running Tests Local Development # Run all tests python run_tests.py # Run with coverage coverage run -m pytest coverage report coverage html # Run specific test categories pytest tests/rules/ pytest tests/integration/ pytest tests/system/ Continuous Integration GitHub Actions Workflow name: Test Suite on: [push, pull_request] jobs: test: runs-on: ubuntu-latest strategy: matrix: python-version: [3.8, 3.9, \"3.10\"] steps: - uses: actions/checkout@v2 - name: Set up Python uses: actions/setup-python@v2 with: python-version: ${{ matrix.python-version }} - name: Install dependencies run: | python -m pip install --upgrade pip pip install -r requirements.txt - name: Run tests run: | coverage run -m pytest coverage report coverage xml - name: Upload coverage uses: codecov/codecov-action@v2 ..4. Test Maintenance Regular Activities Review test coverage reports weekly Update tests for new features Refactor tests when needed Review test performance Update test documentation Quality Checks Run mutation testing monthly Review test maintainability Check for flaky tests Verify test isolation ..5. Appendix Test Templates Unit Test Template class TestRuleName(unittest.TestCase): def setUp(self): \"\"\"Setup test environment\"\"\" self.rule = RuleUnderTest() def test_valid_case(self): \"\"\"Test with valid input\"\"\" # Given content = \"valid content\" # When findings = self.rule.check(content) # Then self.assertEqual(len(findings), 0) def test_invalid_case(self): \"\"\"Test with invalid input\"\"\" # Given content = \"invalid content\" # When findings = self.rule.check(content) # Then self.assertEqual(len(findings), 1) self.assertEqual(findings[0].severity, Severity.ERROR) Test Checklists New Feature Checklist Unit tests written Integration tests updated System tests verified Coverage goals met Documentation updated Test Review Checklist Tests follow patterns Coverage adequate Edge cases covered Error cases tested Documentation clear ..6. References Pytest Documentation Coverage.py Documentation Codecov GitHub Action .1. Usage Guide .1.1. Command Line Interface Basic Usage # Check a single file asciidoc-lint document.adoc # Check multiple files asciidoc-lint doc1.adoc doc2.adoc # Check with specific output format asciidoc-lint --format json document.adoc # Use specific configuration asciidoc-lint --config my-config.yml document.adoc Command Line Options Option Default Description --format console Output format (console, json, html) --config None Path to configuration file --verbose False Enable verbose output --quiet False Suppress non-error output .1.2. Configuration Configuration File # .asciidoc-lint.yml rules: HEAD001: enabled: true severity: error HEAD002: enabled: true severity: warning Rule Configuration Enable/disable rules Set severity levels Configure rule-specific options Set file patterns .1.3. Output Formats Console Output document.adoc:15 ERROR: Heading level skipped document.adoc:23 WARNING: Heading should start with uppercase JSON Output { \"findings\": [ { \"rule\": \"HEAD001\", \"severity\": \"error\", \"message\": \"Heading level skipped\", \"line\": 15 } ] } HTML Report Generates a detailed HTML report with: Summary statistics Detailed findings Source context Rule explanations .1.4. Integration Git Pre-commit Hook #!/bin/sh files=$(git diff --cached --name-only --diff-filter=ACM | grep '.adoc$') if [ -n \"$files\" ]; then asciidoc-lint $files fi CI/CD Integration GitHub Actions Example name: Lint AsciiDoc on: [push, pull_request] jobs: lint: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Lint Documentation run: | pip install asciidoc-linter asciidoc-lint docs/ .1.5. Best Practices Document Organization Use consistent heading levels Add blank lines around blocks Use proper formatting Include alt text for images Error Resolution Table 2. Common Issues and Solutions Issue Solution Skipped heading level Ensure heading levels increment by one Missing space after = Add space after heading markers Multiple top-level headings Use only one level-1 heading per document .1.6. Troubleshooting Common Problems Configuration file not found Rule conflicts Performance issues False positives Debug Mode # Enable debug output asciidoc-lint --debug document.adoc # Show rule processing details asciidoc-lint --verbose document.adoc .2. AsciiDoc Linter Rules .2.1. Heading Rules HEAD001: Heading Hierarchy Ensures proper heading level incrementation (no skipped levels). Description This rule checks that heading levels are not skipped. For example, you cannot go from a level 1 heading (=) directly to a level 3 heading (===) without having a level 2 heading (==) in between. Examples Valid Heading Hierarchy == Document Title (Level 1) === Section (Level 2) ==== Subsection (Level 3) === Another Section (Level 2) Invalid Heading Hierarchy == Document Title (Level 1) ==== Subsection (Level 3) // Error: Skipped Level 2 HEAD002: Heading Format Ensures proper heading format (spacing and capitalization). Description This rule checks two aspects of heading format: 1. There must be a space after the = characters 2. The heading text should start with an uppercase letter Examples Valid Heading Format == Document Title === Section Title ==== Subsection Title Invalid Heading Format =Document Title // Error: No space after = === section title // Warning: Starts with lowercase HEAD003: Multiple Top Level Headings Ensures document has only one top-level heading. Description This rule checks that there is only one level 1 heading (=) in the document. Multiple top-level headings can indicate structural problems or accidentally split documents. Examples Valid Single Top Level == Main Document Title === Section One === Section Two Invalid Multiple Top Level == First Title === Section One == Second Title // Error: Multiple top-level headings .2.2. Block Rules BLOCK001: Unterminated Blocks Checks for blocks that are not properly terminated. Description This rule ensures that all block delimiters are properly paired. Each opening delimiter must have a matching closing delimiter. Supported Block Types Listing blocks (----) Example blocks (====) Sidebar blocks (****) Literal blocks (&#8230;&#8203;.) Quote blocks ( _\\_ ) Table blocks (|===) Comment blocks (////) Passthrough blocks (+\\+). Examples Valid Block Termination [source,python] def hello(): print(\"Hello, World!\") .Example Block ==== Some example content ==== Invalid Block Termination [source,python] def hello(): print(\"Hello, World!\") Example 1. Example Block Some example content ==== BLOCK002: Block Spacing Verifies proper spacing around blocks. ===== Description This rule checks that blocks are properly separated from surrounding content with blank lines, improving readability. ===== Examples .Valid Block Spacing [source,asciidoc] Some text before the block. Block content Some text after the block. .Invalid Block Spacing [source,asciidoc] Some text before the block. ---- // Warning: No blank line before block Block content Some text after the block. // Warning: No blank line after block === Whitespace Rules ==== WS001: Whitespace Usage Ensures proper whitespace usage throughout the document. ===== Checks Performed Consecutive Empty Lines : No more than one consecutive empty line List Marker Spacing : Proper space after list markers (*, -, .) Admonition Block Spacing : Blank line before admonition blocks Trailing Whitespace : No trailing spaces at end of lines Tab Usage : No tabs (use spaces instead) Section Title Spacing : Blank lines around section titles ===== Examples Valid Whitespace Usage == Document Title === Section Title * List item 1 * List item 2 NOTE: This is a note. Some text here. Invalid Whitespace Usage == Document Title === Section Title // Missing blank line before *Invalid list item // Missing space after marker NOTE: Invalid note // Missing blank line before Some text here // Trailing spaces Tabbed line // Tab instead of spaces Extra blank line // Too many blank lines === Image Rules ==== IMG001: Image Attributes Verifies image attributes and file references. ===== Description This rule checks: 1. All images have alt text 2. Referenced local images exist 3. Block images have titles 4. Image attributes are properly formatted ===== Examples Valid Image Usage // Inline image with alt text image:icon.png[Icon] // Block image with title and alt text .Figure 1: System Architecture image::diagram.png[Architecture Diagram] // External image with alt text image:https://example.com/img.png[Example Image] Invalid Image Usage // Missing alt text image:icon.png[] // Missing title for block image image::diagram.png[Diagram] // Non-existent local file image::missing.png[Missing Image] === Planned Rules ==== TABLE001: Table Formatting (Planned) Will check table formatting consistency: * Column alignment * Header row presence * Cell content formatting ==== LINK001: Link Verification (Planned) Will verify: * Internal cross-references * External link validity * Anchor definitions ==== FMT001: Format Consistency (Planned) Will check: * Consistent emphasis style * List formatting * Admonition usage "
},

{
    "id": 16,
    "uri": "manual/rules.html",
    "menu": "manual",
    "title": "AsciiDoc Linter Rules",
    "text": " Table of Contents AsciiDoc Linter Rules Heading Rules Block Rules AsciiDoc Linter Rules Heading Rules HEAD001: Heading Hierarchy Ensures proper heading level incrementation (no skipped levels). Description This rule checks that heading levels are not skipped. For example, you cannot go from a level 1 heading (=) directly to a level 3 heading (===) without having a level 2 heading (==) in between. Examples Valid Heading Hierarchy == Document Title (Level 1) === Section (Level 2) ==== Subsection (Level 3) === Another Section (Level 2) Invalid Heading Hierarchy == Document Title (Level 1) ==== Subsection (Level 3) // Error: Skipped Level 2 HEAD002: Heading Format Ensures proper heading format (spacing and capitalization). Description This rule checks two aspects of heading format: 1. There must be a space after the = characters 2. The heading text should start with an uppercase letter Examples Valid Heading Format == Document Title === Section Title ==== Subsection Title Invalid Heading Format =Document Title // Error: No space after = === section title // Warning: Starts with lowercase HEAD003: Multiple Top Level Headings Ensures document has only one top-level heading. Description This rule checks that there is only one level 1 heading (=) in the document. Multiple top-level headings can indicate structural problems or accidentally split documents. Examples Valid Single Top Level == Main Document Title === Section One === Section Two Invalid Multiple Top Level == First Title === Section One == Second Title // Error: Multiple top-level headings Block Rules BLOCK001: Unterminated Blocks Checks for blocks that are not properly terminated. Description This rule ensures that all block delimiters are properly paired. Each opening delimiter must have a matching closing delimiter. Supported Block Types Listing blocks (----) Example blocks (====) Sidebar blocks (****) Literal blocks (&#8230;&#8203;.) Quote blocks ( _\\_ ) Table blocks (|===) Comment blocks (////) Passthrough blocks (+\\+). Examples Valid Block Termination [source,python] def hello(): print(\"Hello, World!\") .Example Block ==== Some example content ==== Invalid Block Termination [source,python] def hello(): print(\"Hello, World!\") Example 1. Example Block Some example content ==== BLOCK002: Block Spacing Verifies proper spacing around blocks. ===== Description This rule checks that blocks are properly separated from surrounding content with blank lines, improving readability. ===== Examples .Valid Block Spacing [source,asciidoc] Some text before the block. Block content Some text after the block. .Invalid Block Spacing [source,asciidoc] Some text before the block. ---- // Warning: No blank line before block Block content Some text after the block. // Warning: No blank line after block === Whitespace Rules ==== WS001: Whitespace Usage Ensures proper whitespace usage throughout the document. ===== Checks Performed Consecutive Empty Lines : No more than one consecutive empty line List Marker Spacing : Proper space after list markers (*, -, .) Admonition Block Spacing : Blank line before admonition blocks Trailing Whitespace : No trailing spaces at end of lines Tab Usage : No tabs (use spaces instead) Section Title Spacing : Blank lines around section titles ===== Examples Valid Whitespace Usage == Document Title === Section Title * List item 1 * List item 2 NOTE: This is a note. Some text here. Invalid Whitespace Usage == Document Title === Section Title // Missing blank line before *Invalid list item // Missing space after marker NOTE: Invalid note // Missing blank line before Some text here // Trailing spaces Tabbed line // Tab instead of spaces Extra blank line // Too many blank lines === Image Rules ==== IMG001: Image Attributes Verifies image attributes and file references. ===== Description This rule checks: 1. All images have alt text 2. Referenced local images exist 3. Block images have titles 4. Image attributes are properly formatted ===== Examples Valid Image Usage // Inline image with alt text image:icon.png[Icon] // Block image with title and alt text .Figure 1: System Architecture image::diagram.png[Architecture Diagram] // External image with alt text image:https://example.com/img.png[Example Image] Invalid Image Usage // Missing alt text image:icon.png[] // Missing title for block image image::diagram.png[Diagram] // Non-existent local file image::missing.png[Missing Image] === Planned Rules ==== TABLE001: Table Formatting (Planned) Will check table formatting consistency: * Column alignment * Header row presence * Cell content formatting ==== LINK001: Link Verification (Planned) Will verify: * Internal cross-references * External link validity * Anchor definitions ==== FMT001: Format Consistency (Planned) Will check: * Consistent emphasis style * List formatting * Admonition usage "
},

{
    "id": 17,
    "uri": "manual/usage.html",
    "menu": "manual",
    "title": "Usage Guide",
    "text": " Table of Contents Usage Guide Command Line Interface Configuration Output Formats Integration Best Practices Troubleshooting Usage Guide Command Line Interface Basic Usage # Check a single file asciidoc-lint document.adoc # Check multiple files asciidoc-lint doc1.adoc doc2.adoc # Check with specific output format asciidoc-lint --format json document.adoc # Use specific configuration asciidoc-lint --config my-config.yml document.adoc Command Line Options Option Default Description --format console Output format (console, json, html) --config None Path to configuration file --verbose False Enable verbose output --quiet False Suppress non-error output Configuration Configuration File # .asciidoc-lint.yml rules: HEAD001: enabled: true severity: error HEAD002: enabled: true severity: warning Rule Configuration Enable/disable rules Set severity levels Configure rule-specific options Set file patterns Output Formats Console Output document.adoc:15 ERROR: Heading level skipped document.adoc:23 WARNING: Heading should start with uppercase JSON Output { \"findings\": [ { \"rule\": \"HEAD001\", \"severity\": \"error\", \"message\": \"Heading level skipped\", \"line\": 15 } ] } HTML Report Generates a detailed HTML report with: Summary statistics Detailed findings Source context Rule explanations Integration Git Pre-commit Hook #!/bin/sh files=$(git diff --cached --name-only --diff-filter=ACM | grep '.adoc$') if [ -n \"$files\" ]; then asciidoc-lint $files fi CI/CD Integration GitHub Actions Example name: Lint AsciiDoc on: [push, pull_request] jobs: lint: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Lint Documentation run: | pip install asciidoc-linter asciidoc-lint docs/ Best Practices Document Organization Use consistent heading levels Add blank lines around blocks Use proper formatting Include alt text for images Error Resolution Table 1. Common Issues and Solutions Issue Solution Skipped heading level Ensure heading levels increment by one Missing space after = Add space after heading markers Multiple top-level headings Use only one level-1 heading per document Troubleshooting Common Problems Configuration file not found Rule conflicts Performance issues False positives Debug Mode # Enable debug output asciidoc-lint --debug document.adoc # Show rule processing details asciidoc-lint --verbose document.adoc "
},

{
    "id": 18,
    "uri": "manual/introduction.html",
    "menu": "manual",
    "title": "Introduction",
    "text": " Table of Contents Introduction About the Project Key Features Project Goals Technical Overview Getting Started Current Status Introduction About the Project AsciiDoc Linter is a Python-based tool designed to help maintain high-quality AsciiDoc documentation. It checks your AsciiDoc files for common issues and style violations, helping teams maintain consistent documentation standards. As part of the docToolchain project ( https://doctoolchain.org ), it integrates well with existing documentation workflows. Key Features Heading structure validation Proper hierarchy (no skipped levels) Consistent formatting Single top-level heading Block validation Proper block termination Consistent spacing Whitespace consistency Line spacing List formatting Tab detection Image validation Attribute checking File existence verification Multiple output formats (console, JSON, HTML) Project Goals Improve documentation quality through automated checks Enforce consistent styling across documentation Reduce manual review effort Catch common mistakes early in the documentation process Support documentation as code practices Integrate with existing documentation toolchains Technical Overview Table 1. Technology Stack Component Description Language Python 3.8+ Testing unittest framework Documentation AsciiDoc Configuration YAML/JSON (planned) Getting Started Prerequisites Python 3.8 or higher Git (for installation) Installation Note Direct installation via pip is planned for future releases. Currently, installation is done via git clone. # Clone the repository git clone https://github.com/docToolchain/asciidoc-linter.git # Navigate to the project directory cd asciidoc-linter # Install the package pip install . Basic Usage # Check a single file asciidoc-lint document.adoc # Check multiple files asciidoc-lint doc1.adoc doc2.adoc # Get help asciidoc-lint --help Current Status Implemented Features Core linting engine Basic rule set (headings, blocks, whitespace, images) Command-line interface Multiple output formats Planned Features Configuration system (YAML/JSON) Additional rule sets (tables, links, cross-references) Direct installation via pip IDE integration Git pre-commit hooks "
},

{
    "id": 19,
    "uri": "manual/development.html",
    "menu": "manual",
    "title": "Development Guide",
    "text": " Table of Contents Development Guide Setting Up Development Environment Project Structure Current Implementation Status Adding New Rules Code Style Testing Pull Request Process Release Process Getting Help Development Guide Setting Up Development Environment Clone the Repository git clone https://github.com/docToolchain/asciidoc-linter.git cd asciidoc-linter Create Virtual Environment python -m venv venv source venv/bin/activate # On Windows: venv\\Scripts\\activate pip install -e . Project Structure asciidoc-linter/  asciidoc_linter/ # Main package   __init__.py   cli.py # Command line interface   rules/ # Rule implementations    __init__.py    base.py # Base classes for rules    heading_rules.py    block_rules.py    whitespace_rules.py    image_rules.py   parser.py # AsciiDoc parser   reporter.py # Output formatters  tests/ # Test files   rules/ # Rule-specific tests  docs/ # Documentation  README.adoc Current Implementation Status Implemented Features Core rule engine with base classes Rule implementations: Heading rules (hierarchy, format, multiple top-level) Block rules (termination, spacing) Whitespace rules (spacing, formatting) Image rules (attributes, file verification) Basic command line interface Multiple output formats (console, JSON, HTML) Comprehensive test suite Planned Features Configuration system (YAML/JSON) Rule enabling/disabling Severity customization Custom rule parameters Additional rule types IDE integration Git hooks Adding New Rules Rule Implementation Steps Create a new rule class: from .base import Rule, Finding, Severity, Position class MyNewRule(Rule): \"\"\" RULE_ID: Short description. Detailed explanation of what the rule checks. \"\"\" def __init__(self): super().__init__() self.id = \"RULE_ID\" @property def description(self) -&gt; str: return \"Description of what this rule checks\" def check(self, content: str) -&gt; List[Finding]: findings = [] # Implementation here return findings Add tests for the rule: class TestMyNewRule(unittest.TestCase): def setUp(self): self.rule = MyNewRule() def test_valid_case(self): content = \"Valid content\" findings = self.rule.check(content) self.assertEqual(len(findings), 0) def test_invalid_case(self): content = \"Invalid content\" findings = self.rule.check(content) self.assertEqual(len(findings), 1) self.assertEqual(findings[0].rule_id, \"RULE_ID\") Register the rule in the linter Update documentation Rule Guidelines Clear rule IDs and descriptions Meaningful error messages Proper severity levels Contextual information in findings Comprehensive test cases Documentation with examples Code Style Python Guidelines Follow PEP 8 Use type hints Write docstrings (Google style) Keep functions focused and testable Maximum line length: 100 characters Use meaningful variable names Documentation Guidelines Use AsciiDoc format Include examples for all features Explain error messages Document configuration options Keep README.adoc up to date Testing Running Tests # Run all tests python run_tests.py # Run specific test file python -m unittest tests/rules/test_heading_rules.py # Run specific test case python -m unittest tests.rules.test_heading_rules.TestHeadingHierarchyRule Test Guidelines Write tests for all new features Include both positive and negative test cases Test edge cases Maintain high test coverage Use meaningful test names Pull Request Process Create feature branch Implement changes Add/update tests Update documentation Run full test suite Submit PR Release Process Update version number in init .py Update changelog Run full test suite Create release notes Tag release Build and publish Getting Help GitHub Issues: https://github.com/docToolchain/asciidoc-linter/issues Project Wiki: https://github.com/docToolchain/asciidoc-linter/wiki docToolchain Community: https://doctoolchain.org/community "
},

{
    "id": 20,
    "uri": "canvas/architecture-canvas.html",
    "menu": "canvas",
    "title": "Architecture Communication Canvas: AsciiDoc Linter",
    "text": " Table of Contents Architecture Communication Canvas: AsciiDoc Linter Architecture Communication Canvas: AsciiDoc Linter .canvas tr:nth-child(1) td:nth-child(1), .canvas tr:nth-child(1) td:nth-child(2), .canvas tr:nth-child(2) td:nth-child(1), .canvas tr:nth-child(3) td:nth-child(1), .canvas tr:nth-child(4) td:nth-child(1) { background-color: #8fe4b4; border: 1px solid black; } .canvas tr:nth-child(1) td:nth-child(3), .canvas tr:nth-child(1) td:nth-child(4), .canvas tr:nth-child(4) td:nth-child(2) { background-color: #94d7ef; border: 1px solid black; } .canvas tr:nth-child(5) td:nth-child(1) { background-color: #ffc7c6; border: 1px solid black; } Value Proposition Automated quality assurance for AsciiDoc documentation Consistent documentation style across projects Early detection of documentation issues Reduced review effort Integration with CI/CD pipelines Core Functions Lint AsciiDoc files for common issues Check heading structure and format Validate document consistency Generate detailed reports Configurable rule sets Multiple output formats (console, JSON, HTML) Git pre-commit hook integration Core Decisions - Good or Bad Good: Python as implementation language (wide adoption, great libraries) Modular rule system for easy extension Clear separation of concerns (rules, parser, reporter) Test-driven development approach AsciiDoc for documentation Bad: Limited to AsciiDoc format No real-time linting No IDE integration yet Strategic: Focus on documentation quality Extensible architecture Community-driven rule development Technologies Python 3.8+ unittest framework AsciiDoc parser YAML/JSON for configuration Git integration CI/CD tools HTML report generation Key Stakeholder Documentation writers Technical authors Development teams Documentation maintainers Open source projects Technical documentation teams Quality assurance teams Quality Requirements Performance: Fast processing for CI/CD Extensibility: Easy to add new rules Reliability: No false positives Usability: Clear error messages Configurability: Flexible rule settings Maintainability: Well-documented code Testability: Comprehensive test suite Business Context External Systems: Version Control Systems (Git) CI/CD Pipelines Documentation Build Tools IDE Plugins (planned) Issue Tracking Systems Data Flow: AsciiDoc files as input Configuration files (YAML/JSON) Lint reports as output Integration webhooks Components / Modules Core Risks and Missing Information Risks: Performance impact on large documentation sets False positives affecting user acceptance Complexity of rule configurations Integration challenges with existing tools Maintenance of rule set as AsciiDoc evolves Missing Information: Real-world usage patterns Common documentation anti-patterns IDE integration requirements Performance benchmarks User preferences for rule configuration Software Architecture Canvas by Gernot Starke, Patrick Roos and arc42 Contributors is licensed under Attribution-ShareAlike 4.0 International "
},

{
    "id": 21,
    "uri": "readme/README.html",
    "menu": "readme",
    "title": "README.adoc",
    "text": " Table of Contents README.adoc - Project documentation AsciiDoc Linter About Features Implemented Rules Planned Rules Installation Usage Basic Usage Output Formats Example Output Development Current Status Running Tests Project Structure Contributing Development Guidelines License Acknowledgments Roadmap Contact README.adoc - Project documentation AsciiDoc Linter A Python-based linter for AsciiDoc files that helps maintain consistent documentation quality and style. Part of the docToolchain project. About AsciiDoc Linter is a command-line tool that checks your AsciiDoc files for common issues and style violations. It helps maintain consistent documentation by enforcing rules for heading structure, formatting, whitespace, and image usage. This project is part of docToolchain ( https://doctoolchain.org ), a collection of documentation tools and best practices. Features Implemented Rules Rule ID Description Severity Status HEAD001 Check for proper heading hierarchy (no skipping levels) ERROR  Stable HEAD002 Verify heading format (spacing and capitalization) ERROR/WARNING  Stable HEAD003 Detect multiple top-level headers ERROR  Stable BLOCK001 Check for unterminated blocks (listing, example, sidebar, etc.) ERROR  Stable BLOCK002 Verify proper spacing around blocks WARNING  Stable WS001 Check whitespace usage (blank lines, list markers, tabs) WARNING  Stable IMG001 Verify image attributes and file references WARNING/ERROR  Stable TABLE001 Table formatting consistency WARNING/ERROR  Beta Planned Rules TABLE002: Table content validation LINK001: Broken internal references FMT001: Markdown-compatible styles detection Installation # Clone the repository git clone https://github.com/docToolchain/asciidoc-linter.git # Navigate to the project directory cd asciidoc-linter # Install the package pip install . Usage Basic Usage # Check a single file asciidoc-lint document.adoc # Check multiple files asciidoc-lint doc1.adoc doc2.adoc # Check with specific output format asciidoc-lint --format json document.adoc Output Formats The linter supports three output formats: console (default): Human-readable output with color plain : Human-readable output without color json : Machine-readable JSON format html : HTML report format Example Output Checking file: document.adoc ERROR: Heading level skipped: found h3 after h1 (line 15) === Advanced Topics WARNING: Heading should start with uppercase letter (line 23) == introduction to concepts ERROR: Unterminated listing block starting (line 45) ---- WARNING: Block should be preceded by a blank line (line 67) ---- ERROR: Multiple top-level headings found (line 30) First heading at line 1: 'Document Title' WARNING: Missing alt text for image: diagram.png (line 80) image::diagram.png[] Development Current Status Test Coverage: 94% Test Success Rate: 100% (127/127 tests passing) Known Issues: Table content validation needs improvement Rules.py requires test coverage Reporter module needs additional tests Running Tests # Run all tests python -m pytest # Run specific test file python -m pytest tests/rules/test_heading_rules.py # Run tests with coverage python run_tests_html.py Project Structure asciidoc-linter/  asciidoc_linter/   __init__.py   cli.py   linter.py   parser.py   reporter.py   rules/   __init__.py   base.py   base_rules.py   block_rules.py   heading_rules.py   image_rules.py   table_rules.py   whitespace_rules.py  tests/   __init__.py   test_base.py   test_cli.py   test_linter.py   test_reporter.py   rules/   test_block_rules.py   test_heading_rules.py   test_image_rules.py   test_table_rules.py   test_whitespace_rules.py  docs/   arc42/   manual/   test-results/   requirements.adoc   implementation_plan.adoc  README.adoc  run_tests.py Contributing Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change. Development Guidelines Write tests for new rules Update documentation Follow Python code style guidelines Add appropriate error messages and context Ensure test coverage remains above 90% License This project is licensed under the MIT License - see the LICENSE file for details. Acknowledgments Part of the docToolchain project ( https://doctoolchain.org ) Inspired by various linting tools and the need for better AsciiDoc quality control Thanks to the AsciiDoc community for their excellent documentation and tools Roadmap Phase 1 (Current)  Basic heading rules  Block structure rules  Whitespace rules  Image validation  Table validation  Configuration system Phase 2 (Next)  Fix table content validation  Improve test coverage  Add link checking  Add format rules Phase 3 (Future)  IDE integration  Git pre-commit hooks  Custom rule development  Performance optimization Contact Project Homepage: https://github.com/docToolchain/asciidoc-linter Issue Tracker: https://github.com/docToolchain/asciidoc-linter/issues docToolchain Homepage: https://doctoolchain.org "
},

{
    "id": 22,
    "uri": "test-results/02-coverage.html",
    "menu": "test-results",
    "title": "Coverage",
    "text": " "
},

{
    "id": 23,
    "uri": "test-results/01-unit-tests.html",
    "menu": "test-results",
    "title": "Unit Tests",
    "text": " "
},

{
    "id": 24,
    "uri": "search.html",
    "menu": "-",
    "title": "search",
    "text": " Search Results "
},

{
    "id": 25,
    "uri": "lunrjsindex.html",
    "menu": "-",
    "title": "null",
    "text": " will be replaced by the index "
},

];
